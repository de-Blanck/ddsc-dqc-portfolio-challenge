---
phase: 01-data-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - tests/test_instance.py
  - README.md
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "SHA256 hash of instance.json is documented in README for integrity verification"
    - "Automated tests verify instance.json schema, parameters, and matrix properties"
    - "Tests verify hash integrity matches what is documented in README"
    - "pytest and scipy are declared as dev/test dependencies"
  artifacts:
    - path: "tests/test_instance.py"
      provides: "Pytest validation suite for instance.json"
      min_lines: 60
    - path: "README.md"
      provides: "SHA256 hash documentation for instance integrity"
      contains: "SHA256"
    - path: "requirements.txt"
      provides: "Updated dependencies including pytest and scipy"
      contains: "pytest"
  key_links:
    - from: "tests/test_instance.py"
      to: "instance.json"
      via: "json.load and numpy validation"
      pattern: "instance\\.json"
    - from: "tests/test_instance.py"
      to: "README.md"
      via: "hash comparison extracted from README"
      pattern: "README"
    - from: "README.md"
      to: "instance.json"
      via: "documented SHA256 hash"
      pattern: "SHA256"
---

<objective>
Create pytest validation tests for instance.json integrity and document the SHA256 hash in README so participants can verify their instance data is unmodified.

Purpose: Tests provide automated guardrails ensuring instance.json is never accidentally corrupted. The README hash gives participants a way to verify data integrity after cloning.
Output: tests/test_instance.py with schema + matrix + hash tests. README updated with SHA256 hash in a clear section. requirements.txt updated with pytest and scipy.
</objective>

<execution_context>
@C:\Users\Rune\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Rune\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
@scripts/evaluate.py
@instance.json
@README.md
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pytest validation suite for instance.json</name>
  <files>tests/test_instance.py, requirements.txt</files>
  <action>
1. Update requirements.txt to add test/validation dependencies. Append these lines:
   ```
   pytest>=7.0
   scipy>=1.11
   ```
   Keep existing dependencies (numpy>=1.26, pandas>=2.1, requests>=2.31) unchanged.

2. Create tests/test_instance.py with the following test functions. Use pathlib for file paths relative to repo root. The test file should be runnable with `pytest tests/test_instance.py -v` from the repo root.

   Include a module-level fixture that loads instance.json once:
   ```python
   @pytest.fixture(scope="module")
   def instance():
       with open(INSTANCE_PATH) as f:
           return json.load(f)
   ```
   Where INSTANCE_PATH = Path(__file__).parent.parent / "instance.json"

   Tests to include:

   a. **test_instance_exists** — Assert instance.json file exists at repo root.

   b. **test_required_fields(instance)** — Assert instance has all required keys: tickers, K, lambda, penalty_A, mu, sigma

   c. **test_dimensions(instance)** — Assert:
      - len(tickers) == 20
      - len(mu) == 20
      - len(sigma) == 20
      - Each row in sigma has length 20

   d. **test_locked_parameters(instance)** — Assert:
      - K == 5
      - lambda == 0.5
      - penalty_A == 10.0

   e. **test_tickers_match(instance)** — Load data/tickers.txt and verify tickers in instance.json match (after lowercasing and stripping).

   f. **test_sigma_symmetric(instance)** — Convert sigma to numpy array. Assert np.allclose(sigma, sigma.T).

   g. **test_sigma_positive_semidefinite(instance)** — Compute eigenvalues with np.linalg.eigvalsh(). Assert all eigenvalues >= -1e-10 (allowing numerical precision tolerance).

   h. **test_mu_reasonable_range(instance)** — Assert all mu values are between -1.0 and 1.0 (daily log returns should be small). This catches data corruption where values are wildly wrong.

   i. **test_sigma_diagonal_positive(instance)** — Assert all diagonal elements of sigma > 0 (variances must be positive).

   j. **test_hash_integrity(instance)** — Compute SHA256 of instance.json file bytes. Read README.md and extract the documented SHA256 hash using regex pattern `[Ss][Hh][Aa]256.*?([a-f0-9]{64})`. Assert computed hash matches documented hash.

   k. **test_json_deterministic** — Load instance.json, re-serialize with json.dumps(data, indent=2, sort_keys=True) + trailing newline, compute SHA256 of that string, and compare to SHA256 of the file bytes. They should match, proving the file was written with sort_keys=True.

   Use clear assertion messages for every assert so failures are informative.
  </action>
  <verify>
- `pip install pytest>=7.0 scipy>=1.11` succeeds
- `pytest tests/test_instance.py -v` runs all tests
- All tests pass except test_hash_integrity (which will fail until Task 2 adds the hash to README — that's expected)
- `pytest tests/test_instance.py -v -k "not hash_integrity"` passes all tests
  </verify>
  <done>
- tests/test_instance.py exists with 11 test functions covering schema, dimensions, parameters, matrix properties, and hash integrity
- requirements.txt includes pytest>=7.0 and scipy>=1.11
- All tests except hash_integrity pass (hash_integrity requires README update from Task 2)
  </done>
</task>

<task type="auto">
  <name>Task 2: Document SHA256 hash in README and verify full test suite</name>
  <files>README.md</files>
  <action>
1. Compute the SHA256 hash of instance.json:
   ```python
   import hashlib
   with open('instance.json', 'rb') as f:
       hash_value = hashlib.file_digest(f, 'sha256').hexdigest()
   ```
   If Python < 3.11, use the chunked reading fallback:
   ```python
   sha256 = hashlib.sha256()
   with open('instance.json', 'rb') as f:
       for chunk in iter(lambda: f.read(4096), b''):
           sha256.update(chunk)
   hash_value = sha256.hexdigest()
   ```

2. Update README.md: Add a new section after the "Parameters" table and before the "Getting Started" section (before the `---` separator that precedes "Getting Started"). Insert:

   ```markdown
   ### Instance Data

   The pre-computed challenge instance is committed at [`instance.json`](instance.json). It contains the mean return vector (`mu`), covariance matrix (`Sigma`), and all parameters. You do **not** need to download price data or run `evaluate.py` to generate it — just use the committed file.

   **Integrity verification:**

   ```
   SHA256: <actual_hash_here>
   ```

   Verify with:

   ```bash
   python -c "import hashlib; print(hashlib.sha256(open('instance.json','rb').read()).hexdigest())"
   ```
   ```

   Replace `<actual_hash_here>` with the actual computed hash.

3. Also update the "Getting Started" section to reflect that step 2 (download) and step 3 (generate instance) are now OPTIONAL since instance.json is pre-committed. Change steps 2 and 3 to indicate they're optional — participants can skip directly to step 4 (scoring). Example:

   Change step 2 heading to: `### 2. (Optional) Download price data`
   Add a note: "The challenge instance is already committed as `instance.json`. You only need to download raw price data if you want to verify the instance yourself."

   Change step 3 heading to: `### 3. (Optional) Regenerate the challenge instance`
   Add a note: "Skip this step — `instance.json` is already in the repo. Only run this if you want to verify the instance from raw data."

4. Run the full test suite including hash_integrity:
   ```bash
   pytest tests/test_instance.py -v
   ```
   ALL tests should now pass, including test_hash_integrity.
  </action>
  <verify>
- `grep -i "SHA256" README.md` shows the hash line
- The hash in README matches `python -c "import hashlib; print(hashlib.sha256(open('instance.json','rb').read()).hexdigest())"`
- `pytest tests/test_instance.py -v` — ALL 11 tests pass (including hash_integrity)
  </verify>
  <done>
- README.md contains SHA256 hash of instance.json in a clearly marked "Instance Data" section
- README "Getting Started" steps 2 and 3 marked as optional since instance.json is pre-committed
- Full pytest suite passes (all 11 tests green)
- Participants can verify instance integrity by comparing hash
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `pytest tests/test_instance.py -v` — all 11 tests pass
2. SHA256 hash in README matches actual instance.json hash
3. requirements.txt includes pytest and scipy
4. README clearly documents that instance.json is pre-committed and how to verify its integrity
</verification>

<success_criteria>
- 11 pytest tests all pass (schema, dimensions, parameters, tickers, symmetry, PSD, mu range, diagonal, hash integrity, deterministic JSON, file exists)
- SHA256 hash documented in README matches computed hash of instance.json
- README updated to indicate price download and instance generation are optional
- requirements.txt includes pytest>=7.0 and scipy>=1.11
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
